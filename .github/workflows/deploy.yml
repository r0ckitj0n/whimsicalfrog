name: Deploy

on:
  workflow_dispatch:
    inputs:
      ref:
        description: "Git ref to deploy (branch or tag)"
        required: false
        default: "main"
  push:
    branches:
      - main
    paths-ignore:
      - 'documentation/**'
      - '*.md'
      - '**/*.md'

permissions:
  contents: read
  deployments: write

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

env:
  SSH_ALIAS: github.com-whf
  REPO: r0ckitj0n/whimsicalfrog
  BASE_URL: ${{ vars.DEPLOY_BASE_URL || 'https://example.com' }}

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    environment:
      name: production
      url: ${{ env.BASE_URL }}/
    permissions:
      contents: read
      deployments: write
    steps:
      - name: Checkout (read-only)
        uses: actions/checkout@v4
        with:
          repository: ${{ env.REPO }}
          ref: ${{ github.event.inputs.ref || github.ref }}
          fetch-depth: 1

      - name: Detect deploy readiness (secrets present)
        id: readiness
        shell: bash
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PASS: ${{ secrets.DEPLOY_PASS }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          WHF_DEPLOY_KEY: ${{ secrets.WHF_DEPLOY_KEY }}
        run: |
          set -euo pipefail
          ready=true
          for v in DEPLOY_HOST DEPLOY_USER DEPLOY_PASS DEPLOY_PATH WHF_DEPLOY_KEY; do
            if [ -z "${!v:-}" ]; then echo "Missing $v"; ready=false; fi
          done
          echo "ready=$ready" >> "$GITHUB_OUTPUT"
          if [ "$ready" != "true" ]; then
            echo "::notice ::Deploy secrets not fully configured; will skip deploy steps but keep workflow green."
          fi

      - name: Setup SSH alias (least-privilege key)
        if: steps.readiness.outputs.ready == 'true'
        uses: ./.github/actions/setup-ssh-alias
        with:
          ssh-private-key: ${{ secrets.WHF_DEPLOY_KEY }}
          ssh-alias: ${{ env.SSH_ALIAS }}
          ssh-host: github.com
          ssh-key-path: ~/.ssh/whf_deploy_key

      - name: Verify repo access via alias (ls-remote)
        if: steps.readiness.outputs.ready == 'true'
        continue-on-error: true
        run: |
          set -euo pipefail
          git ls-remote git@${{ env.SSH_ALIAS }}:${{ env.REPO }} HEAD | tee /tmp/lsremote.txt
          test -s /tmp/lsremote.txt

      - name: Build (placeholder)
        continue-on-error: true
        run: |
          set -euo pipefail
          npm ci || npm install
          npm run build --if-present || true

      - name: Install lftp
        if: steps.readiness.outputs.ready == 'true'
        continue-on-error: true
        run: |
          sudo apt-get update -y
          sudo apt-get install -y lftp

      - name: Deploy (SFTP mirror with lftp)
        if: steps.readiness.outputs.ready == 'true'
        shell: bash
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PASS: ${{ secrets.DEPLOY_PASS }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        continue-on-error: true
        run: |
          set -euo pipefail
          : "${DEPLOY_HOST:?Missing DEPLOY_HOST}"
          : "${DEPLOY_USER:?Missing DEPLOY_USER}"
          : "${DEPLOY_PASS:?Missing DEPLOY_PASS}"
          : "${DEPLOY_PATH:?Missing DEPLOY_PATH}"
          test -d dist || { echo "::error::dist/ not found; ensure build step produced artifacts" >&2; exit 1; }
          printf '%s\n' \
            'set sftp:auto-confirm yes' \
            'set ssl:verify-certificate no' \
            'set cmd:fail-exit yes' \
            "open sftp://$DEPLOY_USER:$DEPLOY_PASS@$DEPLOY_HOST" \
            "mkdir -p $DEPLOY_PATH/dist || true" \
            "mirror --reverse --delete --verbose --only-newer --ignore-time --no-perms dist $DEPLOY_PATH/dist" \
            'bye' > deploy_sftp.txt
          lftp -f deploy_sftp.txt
          rm -f deploy_sftp.txt

      - name: Deploy backgrounds (mtime-based SFTP sync)
        if: steps.readiness.outputs.ready == 'true'
        shell: bash
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PASS: ${{ secrets.DEPLOY_PASS }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        continue-on-error: true
        run: |
          set -euo pipefail
          : "${DEPLOY_HOST:?Missing DEPLOY_HOST}"
          : "${DEPLOY_USER:?Missing DEPLOY_USER}"
          : "${DEPLOY_PASS:?Missing DEPLOY_PASS}"
          : "${DEPLOY_PATH:?Missing DEPLOY_PATH}"
          test -d images/backgrounds || exit 0
          printf '%s\n' \
            'set sftp:auto-confirm yes' \
            'set ssl:verify-certificate no' \
            'set cmd:fail-exit yes' \
            "open sftp://$DEPLOY_USER:$DEPLOY_PASS@$DEPLOY_HOST" \
            "mkdir -p $DEPLOY_PATH/images/backgrounds || true" \
            # mtime-based sync (no --ignore-time) so same-size file changes propagate \
            "mirror --reverse --delete --verbose --only-newer --no-perms images/backgrounds $DEPLOY_PATH/images/backgrounds" \
            'bye' > deploy_backgrounds.txt
          lftp -f deploy_backgrounds.txt
          rm -f deploy_backgrounds.txt

      - name: Deploy item images (mtime-based SFTP sync)
        if: steps.readiness.outputs.ready == 'true'
        shell: bash
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PASS: ${{ secrets.DEPLOY_PASS }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        continue-on-error: true
        run: |
          set -euo pipefail
          : "${DEPLOY_HOST:?Missing DEPLOY_HOST}"
          : "${DEPLOY_USER:?Missing DEPLOY_USER}"
          : "${DEPLOY_PASS:?Missing DEPLOY_PASS}"
          : "${DEPLOY_PATH:?Missing DEPLOY_PATH}"
          test -d images/items || exit 0
          printf '%s\n' \
            'set sftp:auto-confirm yes' \
            'set ssl:verify-certificate no' \
            'set cmd:fail-exit yes' \
            "open sftp://$DEPLOY_USER:$DEPLOY_PASS@$DEPLOY_HOST" \
            "mkdir -p $DEPLOY_PATH/images/items || true" \
            "mirror --reverse --delete --verbose --only-newer --no-perms images/items $DEPLOY_PATH/images/items" \
            'bye' > deploy_items.txt
          lftp -f deploy_items.txt
          rm -f deploy_items.txt

      - name: Deploy signs images (mtime-based SFTP sync)
        if: steps.readiness.outputs.ready == 'true'
        shell: bash
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PASS: ${{ secrets.DEPLOY_PASS }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        continue-on-error: true
        run: |
          set -euo pipefail
          : "${DEPLOY_HOST:?Missing DEPLOY_HOST}"
          : "${DEPLOY_USER:?Missing DEPLOY_USER}"
          : "${DEPLOY_PASS:?Missing DEPLOY_PASS}"
          : "${DEPLOY_PATH:?Missing DEPLOY_PATH}"
          test -d images/signs || exit 0
          printf '%s\n' \
            'set sftp:auto-confirm yes' \
            'set ssl:verify-certificate no' \
            'set cmd:fail-exit yes' \
            "open sftp://$DEPLOY_USER:$DEPLOY_PASS@$DEPLOY_HOST" \
            "mkdir -p $DEPLOY_PATH/images/signs || true" \
            "mirror --reverse --delete --verbose --only-newer --no-perms images/signs $DEPLOY_PATH/images/signs" \
            'bye' > deploy_signs.txt
          lftp -f deploy_signs.txt
          rm -f deploy_signs.txt

      - name: Deploy full site (safe mirror with excludes)
        if: steps.readiness.outputs.ready == 'true'
        shell: bash
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PASS: ${{ secrets.DEPLOY_PASS }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        continue-on-error: true
        run: |
          set -euo pipefail
          : "${DEPLOY_HOST:?Missing DEPLOY_HOST}"
          : "${DEPLOY_USER:?Missing DEPLOY_USER}"
          : "${DEPLOY_PASS:?Missing DEPLOY_PASS}"
          : "${DEPLOY_PATH:?Missing DEPLOY_PATH}"
          # Prepare exclude list to avoid syncing dev/CI/backups and heavy sources
          cat > excludes.txt << 'EOF'
          /.git/
          /.github/
          /.githooks/
          /.husky/
          /.vscode/
          /backups/
          /documentation/
          /docker/
          /node_modules/
          /reports/
          /scripts/
          /dev/
          /server/
          /src/
          /vendor/
          /templates/wf-starter/
          /.DS_Store
          /.php-cs-fixer.cache
          /.stylelintignore
          /.lintstagedignore
          /.eslintignore
          /.gitignore
          /composer.lock
          /package-lock.json
          /package.json
          EOF
          printf '%s\n' \
            'set sftp:auto-confirm yes' \
            'set ssl:verify-certificate no' \
            'set cmd:fail-exit yes' \
            "open sftp://$DEPLOY_USER:$DEPLOY_PASS@$DEPLOY_HOST" \
            "mkdir -p $DEPLOY_PATH || true" \
            # Mirror repository root to DEPLOY_PATH with excludes; keep permissions simple
            "mirror --reverse --delete --only-newer --ignore-time --no-perms --verbose --exclude-glob-from=excludes.txt . $DEPLOY_PATH" \
            'bye' > deploy_full.txt
          lftp -f deploy_full.txt || true
          rm -f deploy_full.txt excludes.txt

      - name: Remote cleanup (remove Vite hot file)
        if: steps.readiness.outputs.ready == 'true'
        shell: bash
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PASS: ${{ secrets.DEPLOY_PASS }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        continue-on-error: true
        run: |
          set -euo pipefail
          : "${DEPLOY_HOST:?Missing DEPLOY_HOST}"
          : "${DEPLOY_USER:?Missing DEPLOY_USER}"
          : "${DEPLOY_PASS:?Missing DEPLOY_PASS}"
          : "${DEPLOY_PATH:?Missing DEPLOY_PATH}"
          printf '%s\n' \
            'set sftp:auto-confirm yes' \
            'set ssl:verify-certificate no' \
            'set cmd:fail-exit yes' \
            "open sftp://$DEPLOY_USER:$DEPLOY_PASS@$DEPLOY_HOST" \
            "cd $DEPLOY_PATH" \
            'rm -f hot' \
            'bye' > cleanup_hot.txt
          lftp -f cleanup_hot.txt || true
          rm -f cleanup_hot.txt

      - name: HTTP verification
        shell: bash
        run: |
          set -euo pipefail
          # Check manifest in typical locations
          CODE=$(curl -s -o /dev/null -w "%{http_code}" "$BASE_URL/dist/.vite/manifest.json") || true
          if [ "$CODE" != "200" ]; then
            CODE=$(curl -s -o /dev/null -w "%{http_code}" "$BASE_URL/dist/manifest.json") || true
          fi
          echo "Manifest HTTP: $CODE"
          # Fetch homepage and probe for one JS and CSS
          HTML=$(curl -s "$BASE_URL/") || true
          APP_JS=$(echo "$HTML" | grep -Eo "/dist/assets/js/app.js-[^\"']+\\.js" | head -n1)
          MAIN_CSS=$(echo "$HTML" | grep -Eo "/dist/assets/[^\"']+\\.css" | head -n1)
          if [ -n "$APP_JS" ]; then
            CJ=$(curl -s -o /dev/null -w "%{http_code}" "$BASE_URL$APP_JS") || true
            echo "JS $APP_JS -> $CJ"
          else
            echo "No app.js asset found in homepage HTML"
          fi
          if [ -n "$MAIN_CSS" ]; then
            CC=$(curl -s -o /dev/null -w "%{http_code}" "$BASE_URL$MAIN_CSS") || true
            echo "CSS $MAIN_CSS -> $CC"
          else
            echo "No CSS asset found in homepage HTML"
          fi

      - name: Fix image permissions
        if: steps.readiness.outputs.ready == 'true'
        shell: bash
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PASS: ${{ secrets.DEPLOY_PASS }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        continue-on-error: true
        run: |
          set -euo pipefail
          : "${DEPLOY_HOST:?Missing DEPLOY_HOST}"
          : "${DEPLOY_USER:?Missing DEPLOY_USER}"
          : "${DEPLOY_PASS:?Missing DEPLOY_PASS}"
          : "${DEPLOY_PATH:?Missing DEPLOY_PATH}"
          printf '%s\n' \
            'set sftp:auto-confirm yes' \
            'set ssl:verify-certificate no' \
            'set cmd:fail-exit yes' \
            "open sftp://$DEPLOY_USER:$DEPLOY_PASS@$DEPLOY_HOST" \
            "cd $DEPLOY_PATH" \
            'chmod 755 images/ || true' \
            'chmod 755 images/items/ || true' \
            'chmod 644 images/items/* || true' \
            'bye' > fix_perms.txt
          lftp -f fix_perms.txt || true
          rm -f fix_perms.txt
