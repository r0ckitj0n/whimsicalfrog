<?php
// Start output buffering and set JSON header early
if (function_exists('ob_start')) { ob_start(); }
if (function_exists('header_remove')) { @header_remove('Content-Type'); }
header('Content-Type: application/json');
// Track whether a JSON response was actually emitted
$__wf_add_order_sent = false;
// Early error capture
register_shutdown_function(function () {
    global $__wf_add_order_sent, $debug, $debugData;
    $error = error_get_last();
    if ($error && in_array($error['type'], [E_ERROR, E_PARSE, E_CORE_ERROR, E_COMPILE_ERROR])) {
        error_log("add-order.php: Fatal error detected: " . print_r($error, true));
        // Clear any buffered output before sending JSON
        while (function_exists('ob_get_level') && ob_get_level() > 0) { @ob_end_clean(); }
        if (!headers_sent()) {
            header('Content-Type: application/json');
            http_response_code(500);
        }
        $__wf_add_order_sent = true;
        echo json_encode(['success' => false, 'error' => 'Fatal error: ' . $error['message']]);
        return;
    }
    // Safety net: if script ended without emitting JSON, return a clear error body
    if (!$__wf_add_order_sent) {
        while (function_exists('ob_get_level') && ob_get_level() > 0) { @ob_end_clean(); }
        if (!headers_sent()) {
            header('Content-Type: application/json');
            http_response_code(500);
        }
        $resp = ['success' => false, 'error' => 'No response generated by add-order.php'];
        if (isset($debug) && $debug) {
            if (!isset($debugData) || !is_array($debugData)) { $debugData = ['notes' => []]; }
            $debugData['notes'][] = 'Shutdown safety-net emitted response due to empty output.';
            $resp['debug'] = $debugData;
        }
        $__wf_add_order_sent = true;
        echo json_encode($resp);
    }
});

require_once __DIR__ . '/config.php';
// NOTE: Do not require email_config.php here. It performs strict runtime checks
// and can throw before our try/catch begins, causing an HTTP 500 during order placement
// if email settings are incomplete. Email sending for orders is handled by
// api/email_notifications.php using EmailHelper and BusinessSettings.
require_once __DIR__ . '/../includes/functions.php';
require_once __DIR__ . '/email_notifications.php';
require_once __DIR__ . '/business_settings_helper.php';
require_once __DIR__ . '/../includes/tax_service.php';
require_once __DIR__ . '/../includes/stock_manager.php';

// Error display controlled centrally in api/config.php
// Content-Type header already set at top of file

// Add error handling for fatal errors
try {

    // Add debugging
    error_log("add-order.php: Received request");
    error_log("add-order.php: Request method: " . $_SERVER['REQUEST_METHOD']);
    // getallheaders() is not available on all SAPIs; guard it
    if (function_exists('getallheaders')) {
        error_log("add-order.php: Headers: " . print_r(getallheaders(), true));
    } else {
        error_log("add-order.php: Headers: getallheaders() not available on this SAPI");
    }
    $rawInput = file_get_contents('php://input');
    error_log("add-order.php: Raw input: " . $rawInput);
    error_log("add-order.php: Raw input length: " . strlen($rawInput));

    // Stock management functions are now available from includes/functions.php

    if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
        http_response_code(405);
        // Clear any buffered notices/warnings
        while (function_exists('ob_get_level') && ob_get_level() > 0) { @ob_end_clean(); }
        echo json_encode(['success' => false,'error' => 'Method not allowed']);
        $__wf_add_order_sent = true;
        exit;
    }

    // Use previously captured $rawInput for JSON decoding to avoid double-reading php://input
    $input = json_decode($rawInput, true);
    if (!$input) {
        $jsonError = json_last_error_msg();
        error_log("add-order.php: JSON decode error: " . $jsonError);
        http_response_code(400);
        while (function_exists('ob_get_level') && ob_get_level() > 0) { @ob_end_clean(); }
        echo json_encode(['success' => false,'error' => 'Invalid JSON: ' . $jsonError]);
        $__wf_add_order_sent = true;
        exit;
    }

    // Debug the parsed input
    error_log("add-order.php: Parsed input: " . print_r($input, true));

    // Debug flag and container
    $debug = !empty($input['debug']);
    $debugData = [
        'received' => $input,
        'notes' => [],
    ];

    $pdo = new PDO($dsn, $user, $pass, $options);

    // Ensure order_items table has size column (migration)
    try {
        $stmt = $pdo->query("SHOW COLUMNS FROM order_items LIKE 'size'");
        $hasSizeCol = $stmt->rowCount() > 0;
        $orderItemSizeMaxLen = null;
        if ($hasSizeCol) {
            // Check existing length and widen if needed
            $row = $stmt->fetch(PDO::FETCH_ASSOC);
            $type = isset($row['Type']) ? strtolower($row['Type']) : '';
            $len = null;
            if (preg_match('/varchar\((\d+)\)/i', $type, $m)) { $len = (int)$m[1]; }
            if ($len !== null) { $orderItemSizeMaxLen = $len; }
            if ($len !== null && $len < 32) {
                try {
                    $pdo->exec("ALTER TABLE order_items MODIFY COLUMN size VARCHAR(32) DEFAULT NULL");
                    error_log("add-order.php: Widened 'size' column to VARCHAR(32)");
                    $orderItemSizeMaxLen = 32;
                } catch (Exception $e) {
                    error_log("add-order.php: Warning - Could not widen size column: " . $e->getMessage());
                }
            }
        } else {
            try {
                $pdo->exec("ALTER TABLE order_items ADD COLUMN size VARCHAR(32) DEFAULT NULL AFTER color");
                error_log("add-order.php: Added 'size' column (VARCHAR(32)) to order_items table");
                $hasSizeCol = true;
                $orderItemSizeMaxLen = 32;
            } catch (Exception $e) {
                // Likely due to permissions or engine limitations; proceed without size column
                error_log("add-order.php: Warning - Could not add size column: " . $e->getMessage());
                $hasSizeCol = false;
            }
        }
    } catch (Exception $e) {
        error_log("add-order.php: Warning - Could not check/add size column: " . $e->getMessage());
        $hasSizeCol = false;
    }

    // Ensure orders table has shippingMethod and shippingAddress columns (migration)
    try {
        $stmt = $pdo->query("SHOW COLUMNS FROM orders LIKE 'shippingMethod'");
        $hasShippingMethodCol = $stmt->rowCount() > 0;
        if (!$hasShippingMethodCol) {
            try {
                $pdo->exec("ALTER TABLE orders ADD COLUMN shippingMethod VARCHAR(50) DEFAULT 'Customer Pickup' AFTER paymentMethod");
                error_log("add-order.php: Added 'shippingMethod' column to orders table");
                $hasShippingMethodCol = true;
            } catch (Exception $e) {
                error_log("add-order.php: Warning - Could not add shippingMethod column: " . $e->getMessage());
                $hasShippingMethodCol = false;
            }
        }
    } catch (Exception $e) {
        error_log("add-order.php: Warning - Could not check/add shippingMethod column: " . $e->getMessage());
        $hasShippingMethodCol = false;
    }
    try {
        $stmt = $pdo->query("SHOW COLUMNS FROM orders LIKE 'shippingAddress'");
        $hasShippingAddressCol = $stmt->rowCount() > 0;
        if (!$hasShippingAddressCol) {
            try {
                $pdo->exec("ALTER TABLE orders ADD COLUMN shippingAddress JSON NULL AFTER shippingMethod");
                error_log("add-order.php: Added 'shippingAddress' column to orders table");
                $hasShippingAddressCol = true;
            } catch (Exception $e) {
                // Fallback: some MySQL versions don't support JSON; we simply won't store it
                error_log("add-order.php: Warning - Could not add shippingAddress column: " . $e->getMessage());
                $hasShippingAddressCol = false;
            }
        }
    } catch (Exception $e) {
        error_log("add-order.php: Warning - Could not check/add shippingAddress column: " . $e->getMessage());
        $hasShippingAddressCol = false;
    }

    // Record detected schema in debug
    if (!isset($hasSizeCol)) { $hasSizeCol = false; }
    if (!isset($hasShippingMethodCol)) { $hasShippingMethodCol = false; }
    if (!isset($hasShippingAddressCol)) { $hasShippingAddressCol = false; }
    if (!empty($debug)) {
        $debugData['schema'] = [
            'order_items.size' => (bool)$hasSizeCol,
            'orders.shippingMethod' => (bool)$hasShippingMethodCol,
            'orders.shippingAddress' => (bool)$hasShippingAddressCol,
        ];
    }

    // Validate required fields
    $required = ['customerId','itemIds','quantities','paymentMethod','total'];
    foreach ($required as $field) {
        if (!isset($input[$field])) {
            http_response_code(400);
            while (function_exists('ob_get_level') && ob_get_level() > 0) { @ob_end_clean(); }
            echo json_encode(['success' => false,'error' => 'Missing field: '.$field]);
            $__wf_add_order_sent = true;
            exit;
        }
    }
    $itemIds = $input['itemIds'];  // These are actually SKUs now
    $quantities = $input['quantities'];
    $colors = $input['colors'] ?? []; // Color information for each item
    $sizes = $input['sizes'] ?? []; // Size information for each item

    // Debug the itemIds array
    error_log("add-order.php: itemIds array: " . print_r($itemIds, true));
    error_log("add-order.php: quantities array: " . print_r($quantities, true));
    error_log("add-order.php: colors array: " . print_r($colors, true));
    error_log("add-order.php: sizes array: " . print_r($sizes, true));

    if (!is_array($itemIds) || !is_array($quantities) || count($itemIds) !== count($quantities)) {
        http_response_code(400);
        while (function_exists('ob_get_level') && ob_get_level() > 0) { @ob_end_clean(); }
        echo json_encode(['success' => false,'error' => 'Invalid items array']);
        $__wf_add_order_sent = true;
        exit;
    }

    // Ensure colors and sizes arrays have same length as items (fill with nulls if needed)
    if (count($colors) < count($itemIds)) {
        $colors = array_pad($colors, count($itemIds), null);
    }
    if (count($sizes) < count($itemIds)) {
        $sizes = array_pad($sizes, count($itemIds), null);
    }

    $paymentMethod = $input['paymentMethod'];
    $shippingMethod = $input['shippingMethod'] ?? 'Customer Pickup'; // Default to Customer Pickup if not provided
    $shippingAddress = $input['shippingAddress'] ?? null; // Shipping address data (optional)

    // --- Compute pricing server-side (subtotal, shipping, tax, total) ---
    $computedSubtotal = 0.0;
    $computedShipping = 0.0;
    $computedTax = 0.0;
    $computedTotal = 0.0;
    $itemsDebug = [];

    // Price lookup
    $priceStmt = $pdo->prepare("SELECT retailPrice FROM items WHERE sku = ?");
    for ($i = 0; $i < count($itemIds); $i++) {
        $sku = $itemIds[$i];
        $qty = (int)($quantities[$i] ?? 0);
        if (!$sku || $qty <= 0) continue;

        $effectiveSku = $sku;
        // Primary lookup
        $priceStmt->execute([$effectiveSku]);
        $p = $priceStmt->fetchColumn();

        // If not found/zero, build candidate SKUs by stripping trailing letters and hyphenated suffixes
        if ($p === false || $p === null || (float)$p <= 0.0) {
            $candidates = [];
            $skuStr = (string)$sku;
            $bases = [];
            $bases[] = $skuStr;
            // Also consider letters-stripped base
            $lettersStripped = preg_replace('/[A-Za-z]+$/', '', $skuStr);
            if ($lettersStripped !== $skuStr) { $bases[] = $lettersStripped; }
            // From each base, progressively drop the last hyphen segment; at each step, also add letters-stripped variant
            foreach (array_unique(array_filter($bases)) as $base) {
                $current = $base;
                while (true) {
                    // Add letters-stripped variant if applicable
                    $ls = preg_replace('/[A-Za-z]+$/', '', $current);
                    if ($ls !== $current) { $candidates[] = $ls; }
                    // Drop last hyphen segment
                    if (strpos($current, '-') === false) { break; }
                    $current = preg_replace('/-[^-]*$/', '', $current);
                    if ($current) { $candidates[] = $current; }
                }
            }

            foreach ($candidates as $cand) {
                $priceStmt->execute([$cand]);
                $candPrice = $priceStmt->fetchColumn();
                if ($candPrice !== false && $candPrice !== null && (float)$candPrice > 0.0) {
                    error_log("add-order.php: Normalized SKU '$sku' -> '$cand' for pricing computation");
                    if ($debug) { $debugData['notes'][] = "Normalized SKU '$sku' -> '$cand' for pricing"; }
                    $effectiveSku = $cand;
                    $p = $candPrice;
                    break;
                }
            }
        }

        if ($p === false || $p === null) { $p = 0.0; }
        $computedSubtotal += ((float)$p) * $qty;
        // Collect per-item debug info
        if ($debug) {
            $itemsDebug[] = [
                'sku' => (string)$sku,
                'lookupSku' => (string)$effectiveSku,
                'qty' => $qty,
                'price' => (float)$p,
                'extended' => round(((float)$p) * $qty, 2)
            ];
        }
    }

    // Shipping rules via BusinessSettings
    $freeThreshold = (float) BusinessSettings::get('free_shipping_threshold', 50.00);
    $localDeliveryFee = (float) BusinessSettings::get('local_delivery_fee', 5.00);
    $rateUSPS = (float) BusinessSettings::get('shipping_rate_usps', 8.99);
    $rateFedEx = (float) BusinessSettings::get('shipping_rate_fedex', 12.99);
    $rateUPS = (float) BusinessSettings::get('shipping_rate_ups', 12.99);

    if ($shippingMethod === 'Customer Pickup') {
        $computedShipping = 0.0;
    } elseif ($computedSubtotal >= $freeThreshold && $freeThreshold > 0) {
        $computedShipping = 0.0;
    } elseif ($shippingMethod === 'Local Delivery') {
        $computedShipping = $localDeliveryFee;
    } elseif ($shippingMethod === 'USPS') {
        $computedShipping = $rateUSPS;
    } elseif ($shippingMethod === 'FedEx') {
        $computedShipping = $rateFedEx;
    } elseif ($shippingMethod === 'UPS') {
        $computedShipping = $rateUPS;
    } else {
        $computedShipping = $rateUSPS; // default fallback
    }

    // Tax (ZIP-based base state tax support)
    $taxShipping = (bool) BusinessSettings::get('tax_shipping', false);
    $settingsEnabled = (bool) BusinessSettings::isTaxEnabled();
    $settingsRate = (float) BusinessSettings::getTaxRate();
    $zipForTax = null;
    if ($shippingAddress && is_array($shippingAddress)) {
        $zipForTax = trim((string)($shippingAddress['zip_code'] ?? ''));
    }
    if (!$zipForTax) {
        // Optional fallback to a configured business zip
        $zipForTax = (string) BusinessSettings::get('business_zip', '');
    }
    $zipState = null;
    $zipRate = null;
    $taxSource = 'settings';
    if (!empty($zipForTax)) {
        $zipRate = (float) TaxService::getTaxRateForZip($zipForTax);
        $zipState = TaxService::lookupStateByZip($zipForTax);
        if ($zipRate > 0) {
            $taxSource = 'zip';
        }
    }
    // Choose rate: prefer positive ZIP rate; otherwise use settings rate if enabled and > 0
    $rateToUse = ($zipRate !== null && $zipRate > 0)
        ? $zipRate
        : (($settingsEnabled && $settingsRate > 0) ? $settingsRate : 0.0);
    $taxEnabled = $rateToUse > 0;
    $taxBase = $computedSubtotal + ($taxShipping ? $computedShipping : 0.0);
    $computedTax = $taxEnabled ? round($taxBase * $rateToUse, 2) : 0.0;

    // Final total
    $computedTotal = round($computedSubtotal + $computedShipping + $computedTax, 2);

    // Populate debug details (after computing totals)
    if ($debug) {
        $debugData['pricing'] = [
            'subtotal' => round($computedSubtotal, 2),
            'shipping' => round($computedShipping, 2),
            'tax' => $computedTax,
            'total' => $computedTotal,
            'clientTotal' => isset($input['total']) ? (float)$input['total'] : null,
            'shippingMethod' => $shippingMethod,
            'freeShippingThreshold' => $freeThreshold,
            'rates' => [
                'localDelivery' => $localDeliveryFee,
                'USPS' => $rateUSPS,
                'FedEx' => $rateFedEx,
                'UPS' => $rateUPS,
            ],
            'taxDetails' => [
                'enabled' => $taxEnabled,
                'rate' => $rateToUse,
                'taxShipping' => $taxShipping,
                'taxBase' => round($taxBase, 2),
                'source' => $taxSource,
                'zip' => $zipForTax,
                'zipState' => $zipState,
            ],
            'items' => $itemsDebug,
        ];
    }

    // Compare against client total (log mismatch, do not fail)
    $clientTotal = isset($input['total']) ? (float)$input['total'] : null;
    if ($clientTotal !== null && abs($clientTotal - $computedTotal) > 0.01) {
        $note = "Client total {$clientTotal} differs from computed total {$computedTotal}, using computed";
        error_log("add-order.php: " . $note);
        if ($debug) { $debugData['notes'][] = $note; }
    }

    // Default payment and order statuses (non-card or pre-charge)
    $paymentStatus = 'Pending';
    $orderStatus   = in_array($paymentMethod, ['Cash','Check']) ? 'Pending' : 'Processing';

    // --- Square payment processing if selected ---
    $squarePaymentId = null;
    if ($paymentMethod === 'Square') {
        $squareToken = $input['squareToken'] ?? '';
        if (!$squareToken) {
            http_response_code(400);
            while (function_exists('ob_get_level') && ob_get_level() > 0) { @ob_end_clean(); }
            echo json_encode(['success' => false, 'error' => 'Missing Square token']);
            $__wf_add_order_sent = true;
            exit;
        }

        // Load Square settings
        $squareEnabled = (bool) BusinessSettings::get('square_enabled', false);
        $squareEnv = (string) BusinessSettings::get('square_environment', 'sandbox');
        $squareAccessToken = (string) BusinessSettings::get('square_access_token', '');
        $squareLocationId = (string) BusinessSettings::get('square_location_id', '');

        if (!$squareEnabled || empty($squareAccessToken) || empty($squareLocationId)) {
            error_log('add-order.php: Square not properly configured');
            echo json_encode(['success' => false, 'error' => 'Payment configuration error']);
            $__wf_add_order_sent = true;
            exit;
        }

        // Prepare Square charge
        $baseUrl = $squareEnv === 'production' ? 'https://connect.squareup.com' : 'https://connect.squareupsandbox.com';

        // We need an orderId for idempotency context; generate early but don't insert yet
        // Generate compact order ID parts here but finalize below to keep single source of truth
        // We'll create a temp idempotency key independent of final orderId
        $idempotencyKey = uniqid('whf_', true);

        $amountCents = (int) round($computedTotal * 100);
        if ($amountCents <= 0) {
            http_response_code(400);
            while (function_exists('ob_get_level') && ob_get_level() > 0) { @ob_end_clean(); }
            echo json_encode(['success' => false, 'error' => 'Invalid amount for payment']);
            $__wf_add_order_sent = true;
            exit;
        }

        $payload = [
            'idempotency_key' => $idempotencyKey,
            'source_id' => $squareToken,
            'amount_money' => [
                'amount' => $amountCents,
                'currency' => BusinessSettings::get('currency_code', 'USD')
            ],
            'location_id' => $squareLocationId,
            'autocomplete' => true,
        ];

        // Optional: include shipping address details if available
        if ($shippingAddress && is_array($shippingAddress)) {
            $payload['shipping_address'] = [
                'address_line_1' => $shippingAddress['address_line1'] ?? '',
                'address_line_2' => $shippingAddress['address_line2'] ?? '',
                'locality' => $shippingAddress['city'] ?? '',
                'administrative_district_level_1' => $shippingAddress['state'] ?? '',
                'postal_code' => $shippingAddress['zip_code'] ?? ''
            ];
        }

        // cURL call to Square Payments API
        $ch = curl_init();
        curl_setopt_array($ch, [
            CURLOPT_URL => $baseUrl . '/v2/payments',
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_TIMEOUT => 30,
            CURLOPT_HTTPHEADER => [
                'Authorization: Bearer ' . $squareAccessToken,
                'Content-Type: application/json',
                'Square-Version: 2023-10-18'
            ],
            CURLOPT_POST => true,
            CURLOPT_POSTFIELDS => json_encode($payload)
        ]);
        $resp = curl_exec($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        $curlErr = curl_error($ch);
        curl_close($ch);

        if ($resp === false || $httpCode < 200 || $httpCode >= 300) {
            error_log('add-order.php: Square payment failed: HTTP ' . $httpCode . ' resp=' . $resp . ' err=' . $curlErr);
            http_response_code(400);
            while (function_exists('ob_get_level') && ob_get_level() > 0) { @ob_end_clean(); }
            echo json_encode(['success' => false, 'error' => 'Payment failed']);
            $__wf_add_order_sent = true;
            exit;
        }

        $respData = json_decode($resp, true);
        if (!isset($respData['payment']) || ($respData['payment']['status'] ?? '') !== 'COMPLETED') {
            error_log('add-order.php: Square payment not completed: ' . $resp);
            http_response_code(400);
            while (function_exists('ob_get_level') && ob_get_level() > 0) { @ob_end_clean(); }
            echo json_encode(['success' => false, 'error' => 'Payment not completed']);
            $__wf_add_order_sent = true;
            exit;
        }

        $squarePaymentId = $respData['payment']['id'] ?? null;
        $paymentStatus = 'Received';
        $orderStatus = 'Processing';
    }

    // Generate compact order ID format: [CustomerNum][MonthDay][ShippingCode][RandomNum]
    // Example: 01A15P23 (8 characters total)
    $date = date('Y-m-d H:i:s');
    $customerId = $input['customerId'];

    // Get last 2 digits of customer number
    $customerNum = '00';
    if (preg_match('/U(\d+)/', $customerId, $matches)) {
        $customerNum = str_pad($matches[1] % 100, 2, '0', STR_PAD_LEFT);
    } else {
        // For non-standard user IDs, create a hash-based 2-digit number
        $customerNum = str_pad(abs(crc32($customerId)) % 100, 2, '0', STR_PAD_LEFT);
    }

    // Get compact date format: Month letter (A-L) + Day (01-31)
    $monthLetters = ['A','B','C','D','E','F','G','H','I','J','K','L'];
    $monthLetter = $monthLetters[date('n') - 1]; // n = 1-12, array is 0-11
    $dayOfMonth = date('d');
    $compactDate = $monthLetter . $dayOfMonth;

    // Get single-character shipping method code
    $shippingCodes = [
        'Customer Pickup' => 'P',
        'Local Delivery' => 'L',
        'USPS' => 'U',
        'FedEx' => 'F',
        'UPS' => 'X'
    ];
    $shippingCode = $shippingCodes[$shippingMethod] ?? 'P';

    // Generate random 2-digit number and ensure uniqueness for the day/customer/shipping code
    $orderId = null;
    $maxAttempts = 50;
    $attempt = 0;
    $existsStmt = null;
    while ($attempt < $maxAttempts) {
        $attempt++;
        $randomNum = str_pad(rand(1, 99), 2, '0', STR_PAD_LEFT);
        $candidate = $customerNum . $compactDate . $shippingCode . $randomNum; // e.g., 01A15P23
        if ($existsStmt === null) {
            $existsStmt = $pdo->prepare('SELECT 1 FROM orders WHERE id = ? LIMIT 1');
        }
        $existsStmt->execute([$candidate]);
        if ($existsStmt->fetchColumn() === false) {
            $orderId = $candidate;
            if (!empty($debug) && $attempt > 1) {
                $debugData['notes'][] = "Order ID collision avoided after $attempt attempts; using $orderId";
            }
            break;
        }
        // Collision; try again
        if (!empty($debug)) { $debugData['notes'][] = "Order ID collision on $candidate; retrying ($attempt)"; }
    }
    if ($orderId === null) {
        // Extremely unlikely; fallback to a UUID-like suffix truncated to keep length reasonable
        $suffix = substr(strtoupper(bin2hex(random_bytes(2))), 0, 4); // 4 hex chars
        $orderId = $customerNum . $compactDate . $shippingCode . substr($suffix, 0, 2); // still 8 chars
        if (!empty($debug)) { $debugData['notes'][] = "Order ID fallback used: $orderId"; }
    }

    $pdo->beginTransaction();
    try {
        // Format shipping address for storage
        $shippingAddressJson = null;
        if ($shippingAddress && is_array($shippingAddress)) {
            $shippingAddressJson = json_encode($shippingAddress);
        }

        // Build INSERT for orders based on available columns
        $orderCols = ['id','userId','total','paymentMethod'];
        $orderVals = [$orderId, $input['customerId'], $computedTotal, $paymentMethod];
        if (!empty($hasShippingMethodCol)) { $orderCols[] = 'shippingMethod'; $orderVals[] = $shippingMethod; }
        if (!empty($hasShippingAddressCol)) { $orderCols[] = 'shippingAddress'; $orderVals[] = $shippingAddressJson; }
        $orderCols = array_merge($orderCols, ['order_status','date','paymentStatus']);
        $orderVals = array_merge($orderVals, [$orderStatus, $date, $paymentStatus]);
        $placeholders = implode(',', array_fill(0, count($orderCols), '?'));
        $sql = "INSERT INTO orders (" . implode(',', $orderCols) . ") VALUES ($placeholders)";
        if (!empty($debug)) {
            $debugData['ordersInsert'] = [
                'sql' => $sql,
                // Show anonymized values to avoid leaking PII; keep structure
                'columns' => $orderCols,
            ];
        }
        $stmt = $pdo->prepare($sql);
        $success = $stmt->execute($orderVals);

        // Get the next order item ID sequence number by finding the highest existing ID
        $maxIdStmt = $pdo->prepare("SELECT id FROM order_items WHERE id REGEXP '^OI[0-9]+$' ORDER BY CAST(SUBSTRING(id, 3) AS UNSIGNED) DESC LIMIT 1");
        $maxIdStmt->execute();
        $maxId = $maxIdStmt->fetchColumn();

        // Extract the sequence number from the highest ID
        $nextSequence = 1; // Default starting sequence
        if ($maxId) {
            $currentSequence = (int)substr($maxId, 2); // Remove 'OI' prefix and convert to int
            $nextSequence = $currentSequence + 1;
            error_log("add-order.php: Found max existing ID '$maxId', next sequence will be $nextSequence");
        } else {
            error_log("add-order.php: No existing order item IDs found, starting from sequence 1");
        }

        // Prepare statements for order items and stock updates
        $priceStmt = $pdo->prepare("SELECT retailPrice FROM items WHERE sku = ?");
        // Prepare order_items insert; include size only if column exists
        if (!empty($hasSizeCol)) {
            $orderItemStmt = $pdo->prepare("INSERT INTO order_items (id, orderId, sku, quantity, price, color, size) VALUES (?, ?, ?, ?, ?, ?, ?)");
        } else {
            $orderItemStmt = $pdo->prepare("INSERT INTO order_items (id, orderId, sku, quantity, price, color) VALUES (?, ?, ?, ?, ?, ?)");
        }

        // Process each item (SKU)
        for ($i = 0; $i < count($itemIds); $i++) {
            try {
            $sku = $itemIds[$i];
            $quantity = (int)$quantities[$i];
            $color = !empty($colors[$i]) ? $colors[$i] : null;
            $size = !empty($sizes[$i]) ? $sizes[$i] : null;
            if (!empty($hasSizeCol) && $size !== null && isset($orderItemSizeMaxLen) && $orderItemSizeMaxLen > 0) {
                if (strlen($size) > $orderItemSizeMaxLen) {
                    $orig = $size;
                    $size = substr($size, 0, $orderItemSizeMaxLen);
                    error_log("add-order.php: Truncated size '$orig' to '$size' to fit column length $orderItemSizeMaxLen");
                    if (!empty($debug)) { $debugData['notes'][] = "Truncated size '$orig' to '$size' to fit column length $orderItemSizeMaxLen"; }
                }
            }

            // Debug each SKU being processed
            error_log("add-order.php: Processing item $i: SKU='$sku', Quantity=$quantity, Color='$color', Size='$size'");

            // Check if SKU is null or empty
            if (empty($sku)) {
                error_log("add-order.php: ERROR - SKU is empty for item $i");
                throw new Exception("SKU is empty for item at index $i");
            }

            // Determine effective SKU and get item price (with advanced normalization fallback)
            $effectiveSku = $sku;
            $priceStmt->execute([$effectiveSku]);
            $price = $priceStmt->fetchColumn();
            if ($price === false || $price === null || (float)$price <= 0.0) {
                $candidates = [];
                $skuStr = (string)$sku;
                $bases = [];
                $bases[] = $skuStr;
                // Also consider letters-stripped base
                $lettersStripped = preg_replace('/[A-Za-z]+$/', '', $skuStr);
                if ($lettersStripped !== $skuStr) { $bases[] = $lettersStripped; }
                // From each base, progressively drop the last hyphen segment; at each step, also add letters-stripped variant
                foreach (array_unique(array_filter($bases)) as $base) {
                    $current = $base;
                    while (true) {
                        // Add letters-stripped variant if applicable
                        $ls = preg_replace('/[A-Za-z]+$/', '', $current);
                        if ($ls !== $current) { $candidates[] = $ls; }
                        // Drop last hyphen segment
                        if (strpos($current, '-') === false) { break; }
                        $current = preg_replace('/-[^-]*$/', '', $current);
                        if ($current) { $candidates[] = $current; }
                    }
                }

                foreach ($candidates as $cand) {
                    $priceStmt->execute([$cand]);
                    $candPrice = $priceStmt->fetchColumn();
                    if ($candPrice !== false && $candPrice !== null && (float)$candPrice > 0.0) {
                        error_log("add-order.php: Normalized SKU '$sku' -> '$cand' for order processing");
                        if ($debug) { $debugData['notes'][] = "Normalized SKU '$sku' -> '$cand' for order processing"; }
                        $effectiveSku = $cand;
                        $price = $candPrice;
                        break;
                    }
                }
            }

            if ($price === false || $price === null) {
                error_log("add-order.php: WARNING - No price found for SKU '$sku', using 0.00");
                $price = 0.00;  // Fallback price
            }

            // Generate order item ID using the next sequence number
            $orderItemId = 'OI' . str_pad($nextSequence + $i, 10, '0', STR_PAD_LEFT);

            // Insert order item with color and size information (store effective SKU)
            error_log("add-order.php: Inserting order item: ID=$orderItemId, OrderID=$orderId, SKU=$effectiveSku (orig '$sku'), Qty=$quantity, Price=$price, Color=$color, Size=$size");
            if (!empty($hasSizeCol)) {
                $orderItemStmt->execute([$orderItemId, $orderId, $effectiveSku, $quantity, $price, $color, $size]);
            } else {
                $orderItemStmt->execute([$orderItemId, $orderId, $effectiveSku, $quantity, $price, $color]);
            }

            // Handle stock reduction - prioritize size-specific, then color-specific, then general
            $stockReduced = false;

            if (!empty($size)) {
                // Size-specific stock reduction - need to get color ID if color is specified
                $colorId = null;
                if (!empty($color)) {
                    $colorStmt = $pdo->prepare("SELECT id FROM item_colors WHERE item_sku = ? AND color_name = ? AND is_active = 1");
                    $colorStmt->execute([$effectiveSku, $color]);
                    $colorResult = $colorStmt->fetch(PDO::FETCH_ASSOC);
                    $colorId = $colorResult ? $colorResult['id'] : null;
                }

                // Manually reduce size-specific stock
                $whereClause = "item_sku = ? AND size_code = ? AND is_active = 1";
                $params = [$effectiveSku, $size];

                if ($colorId) {
                    $whereClause .= " AND color_id = ?";
                    $params[] = $colorId;
                } else {
                    $whereClause .= " AND color_id IS NULL";
                }

                $sizeStockStmt = $pdo->prepare("UPDATE item_sizes SET stock_level = GREATEST(stock_level - ?, 0) WHERE $whereClause");
                $sizeStockStmt->execute(array_merge([$quantity], $params));
                $stockReduced = true;

                // If color is specified, sync color stock from its sizes
                if ($colorId) {
                    $colorSyncStmt = $pdo->prepare("
                        UPDATE item_colors 
                        SET stock_level = (
                            SELECT COALESCE(SUM(stock_level), 0) 
                            FROM item_sizes 
                            WHERE item_sku = ? AND is_active = 1
                        ) 
                        WHERE item_sku = ?
                    ");
                    $colorSyncStmt->execute([$effectiveSku, $effectiveSku]);
                }

                error_log("add-order.php: Size-specific stock reduced for SKU '$sku', Size '$size', Color '$color'");
            }

            if (!$stockReduced && !empty($color)) {
                // Use color-specific stock reduction
                $stockReduced = reduceStockForSale($pdo, $effectiveSku, $quantity, $color, null, false);
                if ($stockReduced) {
                    error_log("add-order.php: Color-specific stock reduced for SKU '$sku', Color '$color'");
                } else {
                    error_log("add-order.php: WARNING - Failed to reduce color stock for SKU '$sku', Color '$color'");
                }
            }

            if (!$stockReduced) {
                // Fall back to regular stock reduction for items without colors/sizes
                $updateStockStmt = $pdo->prepare("UPDATE items SET stockLevel = GREATEST(stockLevel - ?, 0) WHERE sku = ?");
                $updateStockStmt->execute([$quantity, $effectiveSku]);
                error_log("add-order.php: General stock reduced for SKU '$effectiveSku' (orig '$sku')");
            }
            } catch (PDOException $ie) {
                error_log("add-order.php: Item processing failed at index $i (SKU={$itemIds[$i]}): " . $ie->getMessage());
                if (!empty($debug)) {
                    $debugData['itemError'] = [
                        'index' => $i,
                        'sku' => $itemIds[$i],
                        'message' => $ie->getMessage(),
                    ];
                }
                throw $ie; // Rethrow to outer catch which will rollback
            }
        }

        $pdo->commit();

        // Send order confirmation emails (non-fatal)
        $emailResults = null;
        try {
            if (function_exists('sendOrderConfirmationEmails')) {
                $emailResults = sendOrderConfirmationEmails($orderId, $pdo);
            } else {
                error_log("Order $orderId: sendOrderConfirmationEmails function not available");
            }
        } catch (Exception $e) {
            error_log("Order $orderId: Email notification exception: " . $e->getMessage());
        }

        // Log email results but don't fail the order if emails fail
        if ($emailResults) {
            if ($emailResults['customer']) {
                error_log("Order $orderId: Customer confirmation email sent successfully");
            } else {
                error_log("Order $orderId: Failed to send customer confirmation email");
            }

            if ($emailResults['admin']) {
                error_log("Order $orderId: Admin notification email sent successfully");
            } else {
                error_log("Order $orderId: Failed to send admin notification email");
            }
        }
        if ($debug) { $debugData['emailResults'] = $emailResults; }

        error_log("add-order.php: Order created successfully: $orderId");
        $resp = ['success' => true,'orderId' => $orderId];
        if ($debug) { $resp['debug'] = $debugData; }
        // Ensure no previous buffered output interferes with JSON body
        while (function_exists('ob_get_level') && ob_get_level() > 0) { @ob_end_clean(); }
        $jsonOut = json_encode($resp);
        error_log('add-order.php: Sending success response, bytes=' . strlen($jsonOut));
        echo $jsonOut;
        $__wf_add_order_sent = true;
    } catch (PDOException $e) {
        if (isset($pdo) && $pdo instanceof PDO && $pdo->inTransaction()) { $pdo->rollBack(); }
        error_log("add-order.php: Database error: " . $e->getMessage());
        if (!empty($debug)) {
            http_response_code(200); // surface debug in client
        } else {
            http_response_code(500);
        }
        $resp = ['success' => false,'error' => $e->getMessage()];
        if (!empty($debug)) {
            // Attach PDO error info if available
            $pdoInfo = method_exists($e, 'errorInfo') ? $e->errorInfo : (property_exists($e, 'errorInfo') ? $e->errorInfo : null);
            $debugData['pdo'] = [
                'code' => $e->getCode(),
                'errorInfo' => $pdoInfo,
            ];
            $resp['debug'] = $debugData;
        }
        while (function_exists('ob_get_level') && ob_get_level() > 0) { @ob_end_clean(); }
        $jsonOut = json_encode($resp);
        error_log('add-order.php: Sending DB error response, bytes=' . strlen($jsonOut));
        echo $jsonOut;
        $__wf_add_order_sent = true;
    } catch (Throwable $e) {
        if (isset($pdo) && $pdo instanceof PDO && $pdo->inTransaction()) { $pdo->rollBack(); }
        error_log("add-order.php: General error: " . $e->getMessage());
        if (!empty($debug)) {
            http_response_code(200);
        } else {
            http_response_code(500);
        }
        $resp = ['success' => false,'error' => $e->getMessage()];
        if (!empty($debug)) { $resp['debug'] = $debugData; }
        while (function_exists('ob_get_level') && ob_get_level() > 0) { @ob_end_clean(); }
        $jsonOut = json_encode($resp);
        error_log('add-order.php: Sending general error response, bytes=' . strlen($jsonOut));
        echo $jsonOut;
        $__wf_add_order_sent = true;
    }

} catch (Throwable $e) {
    error_log("add-order.php: Fatal error: " . $e->getMessage());
    if (isset($debug) && $debug) {
        http_response_code(200);
    } else {
        http_response_code(500);
    }
    $resp = ['success' => false,'error' => 'Fatal error: ' . $e->getMessage()];
    if (isset($debug) && $debug) { $resp['debug'] = $debugData; }
    while (function_exists('ob_get_level') && ob_get_level() > 0) { @ob_end_clean(); }
    $jsonOut = json_encode($resp);
    error_log('add-order.php: Sending fatal error response, bytes=' . strlen($jsonOut));
    echo $jsonOut;
    $__wf_add_order_sent = true;
}
