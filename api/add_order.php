<?php

// Start output buffering and set JSON header early
if (function_exists('ob_start')) {
    ob_start();
}
if (function_exists('header_remove')) {
    @header_remove('Content-Type');
}
header('Content-Type: application/json');
// Track whether a JSON response was actually emitted
$__wf_add_order_sent = false;
// Early error capture
register_shutdown_function(function () {
    global $__wf_add_order_sent, $debug, $debugData;
    $error = error_get_last();
    if ($error && in_array($error['type'], [E_ERROR, E_PARSE, E_CORE_ERROR, E_COMPILE_ERROR])) {
        if (class_exists('Logger')) {
            Logger::exception('Fatal error in add-order', new Error($error['message'] ?? 'Fatal error'), [
                'endpoint' => 'add-order',
                'error' => $error,
            ]);
        }
        // Clear any buffered output before sending JSON
        while (function_exists('ob_get_level') && ob_get_level() > 0) {
            @ob_end_clean();
        }
        if (!headers_sent()) {
            header('Content-Type: application/json');
            http_response_code(500);
        }
        $__wf_add_order_sent = true;
        echo json_encode(['success' => false, 'error' => 'Fatal error: ' . $error['message']]);
        return;
    }
    // Safety net: if script ended without emitting JSON, return a clear error body
    if (!$__wf_add_order_sent) {
        while (function_exists('ob_get_level') && ob_get_level() > 0) {
            @ob_end_clean();
        }
        if (!headers_sent()) {
            header('Content-Type: application/json');
            http_response_code(500);
        }
        $resp = ['success' => false, 'error' => 'No response generated by add-order.php'];
        if (isset($debug) && $debug) {
            if (!isset($debugData) || !is_array($debugData)) {
                $debugData = ['notes' => []];
            }
            $debugData['notes'][] = 'Shutdown safety-net emitted response due to empty output.';
            $resp['debug'] = $debugData;
        }
        $__wf_add_order_sent = true;
        echo json_encode($resp);
    }
});

require_once __DIR__ . '/config.php';
// NOTE: Do not require email_config.php here. It performs strict runtime checks
// and can throw before our try/catch begins, causing an HTTP 500 during order placement
// if email settings are incomplete. Email sending for orders is handled by
// api/email_notifications.php using EmailHelper and BusinessSettings.
require_once __DIR__ . '/../includes/functions.php';
require_once __DIR__ . '/email_notifications.php';
require_once __DIR__ . '/business_settings_helper.php';
require_once __DIR__ . '/../includes/tax_service.php';
require_once __DIR__ . '/../includes/stock_manager.php';
require_once __DIR__ . '/../includes/response.php';
require_once __DIR__ . '/../includes/database_logger.php';

// Error display controlled centrally in api/config.php
// Content-Type header already set at top of file

// Add error handling for fatal errors
try {

    // Add debugging
    if (class_exists('Logger')) {
        Logger::debug('add-order request received', ['endpoint' => 'add-order']);
    }
    if (class_exists('Logger')) {
        Logger::debug('add-order request method', ['endpoint' => 'add-order', 'method' => $_SERVER['REQUEST_METHOD']]);
    }
    // getallheaders() is not available on all SAPIs; guard it
    if (function_exists('getallheaders')) {
        if (class_exists('Logger')) {
            Logger::debug('add-order headers', ['endpoint' => 'add-order', 'headers' => getallheaders()]);
        }
    } else {
        if (class_exists('Logger')) {
            Logger::debug('add-order headers unavailable', ['endpoint' => 'add-order']);
        }
    }
    $rawInput = file_get_contents('php://input');
    if (class_exists('Logger')) {
        Logger::debug('add-order raw input', ['endpoint' => 'add-order', 'length' => strlen($rawInput)]);
    }

    // Stock management functions are now available from includes/functions.php

    if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
        // Clear any buffered notices/warnings
        while (function_exists('ob_get_level') && ob_get_level() > 0) {
            @ob_end_clean();
        }
        $__wf_add_order_sent = true;
        Response::methodNotAllowed('Method not allowed');
    }

    // Use previously captured $rawInput for JSON decoding to avoid double-reading php://input
    $input = json_decode($rawInput, true);
    if (!$input) {
        $jsonError = json_last_error_msg();
        if (class_exists('Logger')) {
            Logger::debug('add-order JSON decode error', ['endpoint' => 'add-order', 'error' => $jsonError]);
        }
        while (function_exists('ob_get_level') && ob_get_level() > 0) {
            @ob_end_clean();
        }
        $__wf_add_order_sent = true;
        Response::error('Invalid JSON: ' . $jsonError, null, 400);
    }

    // Debug the parsed input
    if (class_exists('Logger')) {
        Logger::debug('add-order parsed input', ['endpoint' => 'add-order', 'input_keys' => array_keys($input)]);
    }

    // Debug flag and container
    $debug = !empty($input['debug']);
    $debugData = [
        'received' => $input,
        'notes' => [],
    ];

    $pdo = Database::getInstance();

    // Ensure order_items table has size column (migration)
    try {
        $cols = Database::queryAll("SHOW COLUMNS FROM order_items LIKE 'size'");
        $hasSizeCol = count($cols) > 0;
        $orderItemSizeMaxLen = null;
        if ($hasSizeCol) {
            // Check existing length and widen if needed
            $row = $cols[0] ?? [];
            $type = isset($row['Type']) ? strtolower($row['Type']) : '';
            $len = null;
            if (preg_match('/varchar\((\d+)\)/i', $type, $m)) {
                $len = (int)$m[1];
            }
            if ($len !== null) {
                $orderItemSizeMaxLen = $len;
            }
            if ($len !== null && $len < 32) {
                try {
                    Database::execute("ALTER TABLE order_items MODIFY COLUMN size VARCHAR(32) DEFAULT NULL");
                    if (class_exists('Logger')) {
                        Logger::info("Widened 'size' column to VARCHAR(32)", ['endpoint' => 'add-order']);
                    }
                    $orderItemSizeMaxLen = 32;
                } catch (Exception $e) {
                    if (class_exists('Logger')) {
                        Logger::debug('Could not widen size column', ['endpoint' => 'add-order', 'error' => $e->getMessage()]);
                    }
                }
            }
        } else {
            try {
                Database::execute("ALTER TABLE order_items ADD COLUMN size VARCHAR(32) DEFAULT NULL AFTER color");
                if (class_exists('Logger')) {
                    Logger::info("Added 'size' column (VARCHAR(32)) to order_items table", ['endpoint' => 'add-order']);
                }
                $hasSizeCol = true;
                $orderItemSizeMaxLen = 32;
            } catch (Exception $e) {
                // Likely due to permissions or engine limitations; proceed without size column
                if (class_exists('Logger')) {
                    Logger::debug('Could not add size column', ['endpoint' => 'add-order', 'error' => $e->getMessage()]);
                }
                $hasSizeCol = false;
            }
        }
    } catch (Exception $e) {
        if (class_exists('Logger')) {
            Logger::debug('Could not check/add size column', ['endpoint' => 'add-order', 'error' => $e->getMessage()]);
        }
        $hasSizeCol = false;
    }

    // Ensure orders table has shippingMethod and shippingAddress columns (migration)
    try {
        $cols = Database::queryAll("SHOW COLUMNS FROM orders LIKE 'shippingMethod'");
        $hasShippingMethodCol = count($cols) > 0;
        if (!$hasShippingMethodCol) {
            try {
                Database::execute("ALTER TABLE orders ADD COLUMN shippingMethod VARCHAR(50) DEFAULT 'Customer Pickup' AFTER paymentMethod");
                if (class_exists('Logger')) {
                    Logger::info("Added 'shippingMethod' column to orders table", ['endpoint' => 'add-order']);
                }
                $hasShippingMethodCol = true;
            } catch (Exception $e) {
                if (class_exists('Logger')) {
                    Logger::debug('Could not add shippingMethod column', ['endpoint' => 'add-order', 'error' => $e->getMessage()]);
                }
                $hasShippingMethodCol = false;
            }
        }
    } catch (Exception $e) {
        if (class_exists('Logger')) {
            Logger::debug('Could not check/add shippingMethod column', ['endpoint' => 'add-order', 'error' => $e->getMessage()]);
        }
        $hasShippingMethodCol = false;
    }
    try {
        $cols = Database::queryAll("SHOW COLUMNS FROM orders LIKE 'shippingAddress'");
        $hasShippingAddressCol = count($cols) > 0;
        if (!$hasShippingAddressCol) {
            try {
                Database::execute("ALTER TABLE orders ADD COLUMN shippingAddress JSON NULL AFTER shippingMethod");
                if (class_exists('Logger')) {
                    Logger::info("Added 'shippingAddress' column to orders table", ['endpoint' => 'add-order']);
                }
                $hasShippingAddressCol = true;
            } catch (Exception $e) {
                // Fallback: some MySQL versions don't support JSON; we simply won't store it
                if (class_exists('Logger')) {
                    Logger::debug('Could not add shippingAddress column', ['endpoint' => 'add-order', 'error' => $e->getMessage()]);
                }
                $hasShippingAddressCol = false;
            }
        }
    } catch (Exception $e) {
        if (class_exists('Logger')) {
            Logger::debug('Could not check/add shippingAddress column', ['endpoint' => 'add-order', 'error' => $e->getMessage()]);
        }
        $hasShippingAddressCol = false;
    }

    // Record detected schema in debug
    if (!isset($hasSizeCol)) {
        $hasSizeCol = false;
    }
    if (!isset($hasShippingMethodCol)) {
        $hasShippingMethodCol = false;
    }
    if (!isset($hasShippingAddressCol)) {
        $hasShippingAddressCol = false;
    }
    if (!empty($debug)) {
        $debugData['schema'] = [
            'order_items.size' => (bool)$hasSizeCol,
            'orders.shippingMethod' => (bool)$hasShippingMethodCol,
            'orders.shippingAddress' => (bool)$hasShippingAddressCol,
        ];
    }

    // Validate required fields
    $required = ['customerId','itemIds','quantities','paymentMethod','total'];
    foreach ($required as $field) {
        if (!isset($input[$field])) {
            while (function_exists('ob_get_level') && ob_get_level() > 0) {
                @ob_end_clean();
            }
            $__wf_add_order_sent = true;
            Response::error('Missing field: ' . $field, null, 400);
        }
    }
    $itemIds = $input['itemIds'];  // These are actually SKUs now
    $quantities = $input['quantities'];
    $colors = $input['colors'] ?? []; // Color information for each item
    $sizes = $input['sizes'] ?? []; // Size information for each item

    // Debug arrays at a glance (lengths only)
    if (class_exists('Logger')) {
        Logger::debug('add-order arrays summary', [
            'endpoint' => 'add-order',
            'itemIds_len' => is_array($itemIds) ? count($itemIds) : null,
            'quantities_len' => is_array($quantities) ? count($quantities) : null,
            'colors_len' => is_array($colors) ? count($colors) : null,
            'sizes_len' => is_array($sizes) ? count($sizes) : null,
        ]);
    }

    if (!is_array($itemIds) || !is_array($quantities) || count($itemIds) !== count($quantities)) {
        while (function_exists('ob_get_level') && ob_get_level() > 0) {
            @ob_end_clean();
        }
        $__wf_add_order_sent = true;
        Response::error('Invalid items array', null, 400);
    }

    // Ensure colors and sizes arrays have same length as items (fill with nulls if needed)
    if (count($colors) < count($itemIds)) {
        $colors = array_pad($colors, count($itemIds), null);
    }
    if (count($sizes) < count($itemIds)) {
        $sizes = array_pad($sizes, count($itemIds), null);
    }

    $paymentMethod = $input['paymentMethod'];
    $shippingMethod = $input['shippingMethod'] ?? 'USPS'; // Default to USPS if not provided
    $shippingAddress = $input['shippingAddress'] ?? null; // Shipping address data (optional)

    // --- Compute pricing server-side (subtotal, shipping, tax, total) ---
    $computedSubtotal = 0.0;
    $computedShipping = 0.0;
    $computedTax = 0.0;
    $computedTotal = 0.0;
    $itemsDebug = [];

    // Price lookup
    for ($i = 0; $i < count($itemIds); $i++) {
        $sku = $itemIds[$i];
        $qty = (int)($quantities[$i] ?? 0);
        if (!$sku || $qty <= 0) {
            continue;
        }

        $effectiveSku = $sku;
        // Primary lookup
        $row = Database::queryOne("SELECT retailPrice FROM items WHERE sku = ?", [$effectiveSku]);
        $p = $row ? $row['retailPrice'] : null;

        // If not found/zero, build candidate SKUs by stripping trailing letters and hyphenated suffixes
        if ($p === false || $p === null || (float)$p <= 0.0) {
            $candidates = [];
            $skuStr = (string)$sku;
            $bases = [];
            $bases[] = $skuStr;
            // Also consider letters-stripped base
            $lettersStripped = preg_replace('/[A-Za-z]+$/', '', $skuStr);
            if ($lettersStripped !== $skuStr) {
                $bases[] = $lettersStripped;
            }
            // From each base, progressively drop the last hyphen segment; at each step, also add letters-stripped variant
            foreach (array_unique(array_filter($bases)) as $base) {
                $current = $base;
                while (true) {
                    // Add letters-stripped variant if applicable
                    $ls = preg_replace('/[A-Za-z]+$/', '', $current);
                    if ($ls !== $current) {
                        $candidates[] = $ls;
                    }
                    // Drop last hyphen segment
                    if (strpos($current, '-') === false) {
                        break;
                    }
                    $current = preg_replace('/-[^-]*$/', '', $current);
                    if ($current) {
                        $candidates[] = $current;
                    }
                }
            }

            foreach ($candidates as $cand) {
                $rowCand = Database::queryOne("SELECT retailPrice FROM items WHERE sku = ?", [$cand]);
                $candPrice = $rowCand ? $rowCand['retailPrice'] : null;
                if ($candPrice !== false && $candPrice !== null && (float)$candPrice > 0.0) {
                    error_log("add-order.php: Normalized SKU '$sku' -> '$cand' for pricing computation");
                    if ($debug) {
                        $debugData['notes'][] = "Normalized SKU '$sku' -> '$cand' for pricing";
                    }
                    $effectiveSku = $cand;
                    $p = $candPrice;
                    break;
                }
            }
        }

        if ($p === false || $p === null) {
            $p = 0.0;
        }
        $computedSubtotal += ((float)$p) * $qty;
        // Collect per-item debug info
        if ($debug) {
            $itemsDebug[] = [
                'sku' => (string)$sku,
                'lookupSku' => (string)$effectiveSku,
                'qty' => $qty,
                'price' => (float)$p,
                'extended' => round(((float)$p) * $qty, 2)
            ];
        }
    }

    // Shipping rules via BusinessSettings (non-strict to avoid 500s when missing)
    $shipCfg = BusinessSettings::getShippingConfig(false);
    $freeThreshold   = (float)$shipCfg['free_shipping_threshold'];
    $localDeliveryFee = (float)$shipCfg['local_delivery_fee'];
    $rateUSPS        = (float)$shipCfg['shipping_rate_usps'];
    $rateFedEx       = (float)$shipCfg['shipping_rate_fedex'];
    $rateUPS         = (float)$shipCfg['shipping_rate_ups'];

    // Shipping rules:
    // - Customer Pickup: always free ($0)
    // - Local Delivery: flat fee $75, never free
    // - Carriers (USPS/FedEx/UPS): eligible for free shipping threshold
    if ($shippingMethod === 'Customer Pickup') {
        $computedShipping = 0.0;
    } elseif ($shippingMethod === 'Local Delivery') {
        $computedShipping = 75.00;
    } elseif ($computedSubtotal >= $freeThreshold && $freeThreshold > 0) {
        $computedShipping = 0.0;
    } elseif ($shippingMethod === 'USPS') {
        $computedShipping = $rateUSPS;
    } elseif ($shippingMethod === 'FedEx') {
        $computedShipping = $rateFedEx;
    } elseif ($shippingMethod === 'UPS') {
        $computedShipping = $rateUPS;
    } else {
        $computedShipping = $rateUSPS; // default fallback
    }

    // Tax (ZIP-based base state tax support) - non-strict config
    $taxCfg = BusinessSettings::getTaxConfig(false);
    $taxShipping = (bool)$taxCfg['taxShipping'];
    $settingsEnabled = (bool)$taxCfg['enabled'];
    $settingsRate = (float)$taxCfg['rate'];
    $zipForTax = null;
    if ($shippingAddress && is_array($shippingAddress)) {
        $zipForTax = trim((string)($shippingAddress['zip_code'] ?? ''));
    }
    if (!$zipForTax) {
        // Fallback to canonical business postal/ZIP
        $zipForTax = (string) BusinessSettings::getBusinessPostal();
    }
    $zipState = null;
    $zipRate = null;
    $taxSource = 'settings';
    if (!empty($zipForTax)) {
        $zipRate = (float) TaxService::getTaxRateForZip($zipForTax);
        $zipState = TaxService::lookupStateByZip($zipForTax);
        if ($zipRate > 0) {
            $taxSource = 'zip';
        }
    }
    // Choose rate: prefer positive ZIP rate; otherwise use settings rate if enabled and > 0
    $rateToUse = ($zipRate !== null && $zipRate > 0)
        ? $zipRate
        : (($settingsEnabled && $settingsRate > 0) ? $settingsRate : 0.0);
    $taxEnabled = $rateToUse > 0;
    $taxBase = $computedSubtotal + ($taxShipping ? $computedShipping : 0.0);
    $computedTax = $taxEnabled ? round($taxBase * $rateToUse, 2) : 0.0;

    // Final total
    $computedTotal = round($computedSubtotal + $computedShipping + $computedTax, 2);

    // Populate debug details (after computing totals)
    if ($debug) {
        $debugData['pricing'] = [
            'subtotal' => round($computedSubtotal, 2),
            'shipping' => round($computedShipping, 2),
            'tax' => $computedTax,
            'total' => $computedTotal,
            'clientTotal' => isset($input['total']) ? (float)$input['total'] : null,
            'shippingMethod' => $shippingMethod,
            'freeShippingThreshold' => $freeThreshold,
            'rates' => [
                'localDelivery' => $localDeliveryFee,
                'USPS' => $rateUSPS,
                'FedEx' => $rateFedEx,
                'UPS' => $rateUPS,
            ],
            'taxDetails' => [
                'enabled' => $taxEnabled,
                'rate' => $rateToUse,
                'taxShipping' => $taxShipping,
                'taxBase' => round($taxBase, 2),
                'source' => $taxSource,
                'zip' => $zipForTax,
                'zipState' => $zipState,
                'hasTaxShippingKey' => isset($taxCfg['hasTaxShippingKey']) ? (bool)$taxCfg['hasTaxShippingKey'] : null,
            ],
            'items' => $itemsDebug,
        ];
    }

    // Compare against client total (log mismatch, do not fail)
    $clientTotal = isset($input['total']) ? (float)$input['total'] : null;
    if ($clientTotal !== null && abs($clientTotal - $computedTotal) > 0.01) {
        $note = "Client total {$clientTotal} differs from computed total {$computedTotal}, using computed";
        if (class_exists('Logger')) {
            Logger::info('add-order client/server total mismatch', ['endpoint' => 'add-order', 'clientTotal' => $clientTotal, 'computedTotal' => $computedTotal]);
        }
        if ($debug) {
            $debugData['notes'][] = $note;
        }
    }

    // Default payment and order statuses (non-card or pre-charge)
    $paymentStatus = 'Pending';
    $orderStatus   = in_array($paymentMethod, ['Cash','Check']) ? 'Pending' : 'Processing';

    // --- Square payment processing if selected ---
    $squarePaymentId = null;
    if ($paymentMethod === 'Square') {
        $squareToken = $input['squareToken'] ?? '';
        if (!$squareToken) {
            while (function_exists('ob_get_level') && ob_get_level() > 0) {
                @ob_end_clean();
            }
            $__wf_add_order_sent = true;
            Response::error('Missing Square token', null, 400);
        }

        // Load Square settings
        $squareEnabled = (bool) BusinessSettings::get('square_enabled', false);
        $squareEnv = (string) BusinessSettings::get('square_environment', 'sandbox');
        $squareAccessToken = (string) BusinessSettings::get('square_access_token', '');
        $squareLocationId = (string) BusinessSettings::get('square_location_id', '');

        if (!$squareEnabled || empty($squareAccessToken) || empty($squareLocationId)) {
            if (class_exists('Logger')) {
                Logger::debug('Square not properly configured', ['endpoint' => 'add-order']);
            }
            $__wf_add_order_sent = true;
            Response::error('Payment configuration error', null, 400);
        }

        // Prepare Square charge
        $baseUrl = $squareEnv === 'production' ? 'https://connect.squareup.com' : 'https://connect.squareupsandbox.com';

        // We need an orderId for idempotency context; generate early but don't insert yet
        // Generate compact order ID parts here but finalize below to keep single source of truth
        // We'll create a temp idempotency key independent of final orderId
        $idempotencyKey = uniqid('whf_', true);

        $amountCents = (int) round($computedTotal * 100);
        if ($amountCents <= 0) {
            while (function_exists('ob_get_level') && ob_get_level() > 0) {
                @ob_end_clean();
            }
            $__wf_add_order_sent = true;
            Response::error('Invalid amount for payment', null, 400);
        }

        $payload = [
            'idempotency_key' => $idempotencyKey,
            'source_id' => $squareToken,
            'amount_money' => [
                'amount' => $amountCents,
                'currency' => BusinessSettings::get('currency_code', 'USD')
            ],
            'location_id' => $squareLocationId,
            'autocomplete' => true,
        ];

        // Optional: include shipping address details if available
        if ($shippingAddress && is_array($shippingAddress)) {
            $payload['shipping_address'] = [
                'address_line_1' => $shippingAddress['address_line1'] ?? '',
                'address_line_2' => $shippingAddress['address_line2'] ?? '',
                'locality' => $shippingAddress['city'] ?? '',
                'administrative_district_level_1' => $shippingAddress['state'] ?? '',
                'postal_code' => $shippingAddress['zip_code'] ?? ''
            ];
        }

        // cURL call to Square Payments API
        $ch = curl_init();
        curl_setopt_array($ch, [
            CURLOPT_URL => $baseUrl . '/v2/payments',
            CURLOPT_RETURNTRANSFER => true,
            CURLOPT_TIMEOUT => 30,
            CURLOPT_HTTPHEADER => [
                'Authorization: Bearer ' . $squareAccessToken,
                'Content-Type: application/json',
                'Square-Version: 2023-10-18'
            ],
            CURLOPT_POST => true,
            CURLOPT_POSTFIELDS => json_encode($payload)
        ]);
        $resp = curl_exec($ch);
        $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        $curlErr = curl_error($ch);
        curl_close($ch);

        if ($resp === false || $httpCode < 200 || $httpCode >= 300) {
            if (class_exists('Logger')) {
                Logger::debug('Square payment failed', ['endpoint' => 'add-order', 'httpCode' => $httpCode, 'resp' => $resp, 'curlErr' => $curlErr]);
            }
            while (function_exists('ob_get_level') && ob_get_level() > 0) {
                @ob_end_clean();
            }
            $__wf_add_order_sent = true;
            Response::error('Payment failed', null, 400);
        }

        $respData = json_decode($resp, true);
        if (!isset($respData['payment']) || ($respData['payment']['status'] ?? '') !== 'COMPLETED') {
            if (class_exists('Logger')) {
                Logger::debug('Square payment not completed', ['endpoint' => 'add-order', 'resp' => $respData]);
            }
            while (function_exists('ob_get_level') && ob_get_level() > 0) {
                @ob_end_clean();
            }
            $__wf_add_order_sent = true;
            Response::error('Payment not completed', null, 400);
        }

        $squarePaymentId = $respData['payment']['id'] ?? null;
        $paymentStatus = 'Received';
        $orderStatus = 'Processing';
    }

    // Generate compact order ID format: [CustomerNum][MonthDay][ShippingCode][RandomNum]
    // Example: 01A15P23 (8 characters total)
    $date = date('Y-m-d H:i:s');
    $customerId = $input['customerId'];

    // Get last 2 digits of customer number
    $customerNum = '00';
    if (preg_match('/U(\d+)/', $customerId, $matches)) {
        $customerNum = str_pad($matches[1] % 100, 2, '0', STR_PAD_LEFT);
    } else {
        // For non-standard user IDs, create a hash-based 2-digit number
        $customerNum = str_pad(abs(crc32($customerId)) % 100, 2, '0', STR_PAD_LEFT);
    }

    // Get compact date format: Month letter (A-L) + Day (01-31)
    $monthLetters = ['A','B','C','D','E','F','G','H','I','J','K','L'];
    $monthLetter = $monthLetters[date('n') - 1]; // n = 1-12, array is 0-11
    $dayOfMonth = date('d');
    $compactDate = $monthLetter . $dayOfMonth;

    // Get single-character shipping method code
    $shippingCodes = [
        'Customer Pickup' => 'P',
        'Local Delivery' => 'L',
        'USPS' => 'U',
        'FedEx' => 'F',
        'UPS' => 'X'
    ];
    $shippingCode = $shippingCodes[$shippingMethod] ?? 'P';

    // Generate random 2-digit number and ensure uniqueness for the day/customer/shipping code
    $orderId = null;
    $maxAttempts = 50;
    $attempt = 0;
    $existsStmt = null;
    while ($attempt < $maxAttempts) {
        $attempt++;
        $randomNum = str_pad(rand(1, 99), 2, '0', STR_PAD_LEFT);
        $candidate = $customerNum . $compactDate . $shippingCode . $randomNum; // e.g., 01A15P23
        $exists = Database::queryOne('SELECT 1 FROM orders WHERE id = ? LIMIT 1', [$candidate]);
        if (!$exists) {
            $orderId = $candidate;
            if (!empty($debug) && $attempt > 1) {
                $debugData['notes'][] = "Order ID collision avoided after $attempt attempts; using $orderId";
            }
            break;
        }
        // Collision; try again
        if (!empty($debug)) {
            $debugData['notes'][] = "Order ID collision on $candidate; retrying ($attempt)";
        }
    }
    if ($orderId === null) {
        // Extremely unlikely; fallback to a UUID-like suffix truncated to keep length reasonable
        $suffix = substr(strtoupper(bin2hex(random_bytes(2))), 0, 4); // 4 hex chars
        $orderId = $customerNum . $compactDate . $shippingCode . substr($suffix, 0, 2); // still 8 chars
        if (!empty($debug)) {
            $debugData['notes'][] = "Order ID fallback used: $orderId";
        }
    }

    Database::beginTransaction();
    try {
        // Format shipping address for storage
        $shippingAddressJson = null;
        if ($shippingAddress && is_array($shippingAddress)) {
            $shippingAddressJson = json_encode($shippingAddress);
        }

        // Build INSERT for orders based on available columns
        $orderCols = ['id','userId','total','paymentMethod'];
        $orderVals = [$orderId, $input['customerId'], $computedTotal, $paymentMethod];
        if (!empty($hasShippingMethodCol)) {
            $orderCols[] = 'shippingMethod';
            $orderVals[] = $shippingMethod;
        }
        if (!empty($hasShippingAddressCol)) {
            $orderCols[] = 'shippingAddress';
            $orderVals[] = $shippingAddressJson;
        }
        $orderCols = array_merge($orderCols, ['order_status','date','paymentStatus']);
        $orderVals = array_merge($orderVals, [$orderStatus, $date, $paymentStatus]);
        $placeholders = implode(',', array_fill(0, count($orderCols), '?'));
        $sql = "INSERT INTO orders (" . implode(',', $orderCols) . ") VALUES ($placeholders)";
        if (!empty($debug)) {
            $debugData['ordersInsert'] = [
                'sql' => $sql,
                // Show anonymized values to avoid leaking PII; keep structure
                'columns' => $orderCols,
            ];
        }
        $success = Database::execute($sql, $orderVals) > 0;

        // Get the next order item ID sequence number by finding the highest existing ID
        $maxRow = Database::queryOne("SELECT id FROM order_items WHERE id REGEXP '^OI[0-9]+$' ORDER BY CAST(SUBSTRING(id, 3) AS UNSIGNED) DESC LIMIT 1");
        $maxId = $maxRow ? $maxRow['id'] : false;

        // Extract the sequence number from the highest ID
        $nextSequence = 1; // Default starting sequence
        if ($maxId) {
            $currentSequence = (int)substr($maxId, 2); // Remove 'OI' prefix and convert to int
            $nextSequence = $currentSequence + 1;
            if (class_exists('Logger')) {
                Logger::debug('Found max existing order item ID', ['endpoint' => 'add-order', 'maxId' => $maxId, 'nextSequence' => $nextSequence]);
            }
        } else {
            if (class_exists('Logger')) {
                Logger::debug('No existing order item IDs found; starting at sequence 1', ['endpoint' => 'add-order']);
            }
        }

        // Prepare order_items insert logic; include size only if column exists
        $orderItemSqlWithSize = "INSERT INTO order_items (id, orderId, sku, quantity, price, color, size) VALUES (?, ?, ?, ?, ?, ?, ?)";
        $orderItemSqlNoSize   = "INSERT INTO order_items (id, orderId, sku, quantity, price, color) VALUES (?, ?, ?, ?, ?, ?)";

        // Process each item (SKU)
        for ($i = 0; $i < count($itemIds); $i++) {
            try {
                $sku = $itemIds[$i];
                $quantity = (int)$quantities[$i];
                $color = !empty($colors[$i]) ? $colors[$i] : null;
                $size = !empty($sizes[$i]) ? $sizes[$i] : null;
                if (!empty($hasSizeCol) && $size !== null && isset($orderItemSizeMaxLen) && $orderItemSizeMaxLen > 0) {
                    if (strlen($size) > $orderItemSizeMaxLen) {
                        $orig = $size;
                        $size = substr($size, 0, $orderItemSizeMaxLen);
                        if (class_exists('Logger')) {
                            Logger::debug('Truncated size to fit column length', ['endpoint' => 'add-order', 'original' => $orig, 'truncated' => $size, 'maxLen' => $orderItemSizeMaxLen]);
                        }
                        if (!empty($debug)) {
                            $debugData['notes'][] = "Truncated size '$orig' to '$size' to fit column length $orderItemSizeMaxLen";
                        }
                    }
                }

                // Debug each SKU being processed
                if (class_exists('Logger')) {
                    Logger::debug('Processing order item', ['endpoint' => 'add-order', 'index' => $i, 'sku' => $sku, 'qty' => $quantity, 'color' => $color, 'size' => $size]);
                }

                // Check if SKU is null or empty
                if (empty($sku)) {
                    if (class_exists('Logger')) {
                        Logger::exception('SKU is empty', new Exception('SKU is empty'), ['endpoint' => 'add-order', 'index' => $i]);
                    }
                    throw new Exception("SKU is empty for item at index $i");
                }

                // Determine effective SKU and get item price (with advanced normalization fallback)
                $effectiveSku = $sku;
                $priceRow = Database::queryOne("SELECT retailPrice FROM items WHERE sku = ?", [$effectiveSku]);
                $price = $priceRow ? $priceRow['retailPrice'] : null;
                if ($price === false || $price === null || (float)$price <= 0.0) {
                    $candidates = [];
                    $skuStr = (string)$sku;
                    $bases = [];
                    $bases[] = $skuStr;
                    // Also consider letters-stripped base
                    $lettersStripped = preg_replace('/[A-Za-z]+$/', '', $skuStr);
                    if ($lettersStripped !== $skuStr) {
                        $bases[] = $lettersStripped;
                    }
                    // From each base, progressively drop the last hyphen segment; at each step, also add letters-stripped variant
                    foreach (array_unique(array_filter($bases)) as $base) {
                        $current = $base;
                        while (true) {
                            // Add letters-stripped variant if applicable
                            $ls = preg_replace('/[A-Za-z]+$/', '', $current);
                            if ($ls !== $current) {
                                $candidates[] = $ls;
                            }
                            // Drop last hyphen segment
                            if (strpos($current, '-') === false) {
                                break;
                            }
                            $current = preg_replace('/-[^-]*$/', '', $current);
                            if ($current) {
                                $candidates[] = $current;
                            }
                        }
                    }

                    foreach ($candidates as $cand) {
                        $candRow = Database::queryOne("SELECT retailPrice FROM items WHERE sku = ?", [$cand]);
                        $candPrice = $candRow ? $candRow['retailPrice'] : null;
                        if ($candPrice !== false && $candPrice !== null && (float)$candPrice > 0.0) {
                            if (class_exists('Logger')) {
                                Logger::info('Normalized SKU for order processing', ['endpoint' => 'add-order', 'original_sku' => (string)$sku, 'normalized_sku' => (string)$cand]);
                            }
                            if ($debug) {
                                $debugData['notes'][] = "Normalized SKU '$sku' -> '$cand' for order processing";
                            }
                            $effectiveSku = $cand;
                            $price = $candPrice;
                            break;
                        }
                    }
                }

                if ($price === false || $price === null) {
                    if (class_exists('Logger')) {
                        Logger::debug('No price found for SKU; using 0.00', ['endpoint' => 'add-order', 'sku' => $sku]);
                    }
                    $price = 0.00;  // Fallback price
                }

                // Generate order item ID using the next sequence number
                $orderItemId = 'OI' . str_pad($nextSequence + $i, 10, '0', STR_PAD_LEFT);

                // Insert order item with color and size information (store effective SKU)
                if (class_exists('Logger')) {
                    Logger::debug('Inserting order item', ['endpoint' => 'add-order', 'orderItemId' => $orderItemId, 'orderId' => $orderId, 'sku' => $effectiveSku, 'origSku' => $sku, 'qty' => $quantity, 'price' => $price, 'color' => $color, 'size' => $size]);
                }
                if (!empty($hasSizeCol)) {
                    Database::execute($orderItemSqlWithSize, [$orderItemId, $orderId, $effectiveSku, $quantity, $price, $color, $size]);
                } else {
                    Database::execute($orderItemSqlNoSize, [$orderItemId, $orderId, $effectiveSku, $quantity, $price, $color]);
                }

                // Handle stock reduction - prioritize size-specific, then color-specific, then general
                $stockReduced = false;

                if (!empty($size)) {
                    // Size-specific stock reduction - need to get color ID if color is specified
                    $colorId = null;
                    if (!empty($color)) {
                        $colorRow = Database::queryOne("SELECT id FROM item_colors WHERE item_sku = ? AND color_name = ? AND is_active = 1", [$effectiveSku, $color]);
                        $colorId = $colorRow ? $colorRow['id'] : null;
                    }

                    // Manually reduce size-specific stock
                    $whereClause = "item_sku = ? AND size_code = ? AND is_active = 1";
                    $params = [$effectiveSku, $size];

                    if ($colorId) {
                        $whereClause .= " AND color_id = ?";
                        $params[] = $colorId;
                    } else {
                        $whereClause .= " AND color_id IS NULL";
                    }

                    Database::execute("UPDATE item_sizes SET stock_level = GREATEST(stock_level - ?, 0) WHERE $whereClause", array_merge([$quantity], $params));
                    $stockReduced = true;

                    // If color is specified, sync color stock from its sizes
                    if ($colorId) {
                        Database::execute(
                            "UPDATE item_colors 
                         SET stock_level = (
                             SELECT COALESCE(SUM(stock_level), 0) 
                             FROM item_sizes 
                             WHERE item_sku = ? AND is_active = 1
                         ) 
                         WHERE item_sku = ?",
                            [$effectiveSku, $effectiveSku]
                        );
                    }

                    error_log("add-order.php: Size-specific stock reduced for SKU '$sku', Size '$size', Color '$color'");
                }

                if (!$stockReduced && !empty($color)) {
                    // Use color-specific stock reduction
                    $stockReduced = reduceStockForSale($pdo, $effectiveSku, $quantity, $color, null, false);
                    if ($stockReduced) {
                        error_log("add-order.php: Color-specific stock reduced for SKU '$sku', Color '$color'");
                    } else {
                        error_log("add-order.php: WARNING - Failed to reduce color stock for SKU '$sku', Color '$color'");
                    }
                }

                if (!$stockReduced) {
                    // Fall back to regular stock reduction for items without colors/sizes
                    Database::execute("UPDATE items SET stockLevel = GREATEST(stockLevel - ?, 0) WHERE sku = ?", [$quantity, $effectiveSku]);
                    error_log("add-order.php: General stock reduced for SKU '$effectiveSku' (orig '$sku')");
                }
            } catch (PDOException $ie) {
                error_log("add-order.php: Item processing failed at index $i (SKU={$itemIds[$i]}): " . $ie->getMessage());
                if (!empty($debug)) {
                    $debugData['itemError'] = [
                        'index' => $i,
                        'sku' => $itemIds[$i],
                        'message' => $ie->getMessage(),
                    ];
                }
                throw $ie; // Rethrow to outer catch which will rollback
            }
        }

        Database::commit();

        try {
            DatabaseLogger::logOrderActivity(
                $orderId,
                'order_created',
                'Order created',
                null,
                $orderStatus ?? null,
                isset($input['customerId']) ? $input['customerId'] : null,
                null
            );
        } catch (Exception $e) {}

        // Send order confirmation emails (non-fatal)
        $emailResults = null;
        try {
            if (function_exists('sendOrderConfirmationEmails')) {
                $emailResults = sendOrderConfirmationEmails($orderId, $pdo);
            } else {
                error_log("Order $orderId: sendOrderConfirmationEmails function not available");
            }
        } catch (Exception $e) {
            error_log("Order $orderId: Email notification exception: " . $e->getMessage());
        }

        // Log email results but don't fail the order if emails fail
        if ($emailResults) {
            if ($emailResults['customer']) {
                error_log("Order $orderId: Customer confirmation email sent successfully");
            } else {
                error_log("Order $orderId: Failed to send customer confirmation email");
            }

            if ($emailResults['admin']) {
                error_log("Order $orderId: Admin notification email sent successfully");
            } else {
                error_log("Order $orderId: Failed to send admin notification email");
            }
        }
        if ($debug) {
            $debugData['emailResults'] = $emailResults;
        }

        error_log("add-order.php: Order created successfully: $orderId");
        $resp = ['success' => true,'orderId' => $orderId];
        if ($debug) {
            $resp['debug'] = $debugData;
        }
        // Ensure no previous buffered output interferes with JSON body
        while (function_exists('ob_get_level') && ob_get_level() > 0) {
            @ob_end_clean();
        }
        $__wf_add_order_sent = true;
        Response::success($resp);
    } catch (PDOException $e) {
        Database::rollBack();
        error_log("add-order.php: Database error: " . $e->getMessage());
        $resp = ['error' => $e->getMessage()];
        if (!empty($debug)) {
            // Attach PDO error info if available
            $pdoInfo = method_exists($e, 'errorInfo') ? $e->errorInfo : (property_exists($e, 'errorInfo') ? $e->errorInfo : null);
            $debugData['pdo'] = [
                'code' => $e->getCode(),
                'errorInfo' => $pdoInfo,
            ];
            $resp['debug'] = $debugData;
        }
        $__wf_add_order_sent = true;
        Response::serverError('Database error', $resp);
    } catch (Exception $e) {
        Database::rollBack();
        error_log("add-order.php: General error: " . $e->getMessage());
        $resp = ['error' => $e->getMessage()];
        if (!empty($debug)) {
            $resp['debug'] = $debugData;
        }
        $__wf_add_order_sent = true;
        Response::serverError('Server error', $resp);
    }

} catch (Throwable $e) {
    error_log("add-order.php: Fatal error: " . $e->getMessage());
    $resp = ['error' => 'Fatal error: ' . $e->getMessage()];
    if (isset($debug) && $debug) {
        $resp['debug'] = $debugData;
    }
    $__wf_add_order_sent = true;
    Response::serverError('Fatal error', $resp);
}
